use std::path::PathBuf;

use argh::FromArgs;
use http::uri::PathAndQuery;
use prost_reflect::{DeserializeOptions, DynamicMessage};
use tonic::{
    Request, Response,
    client::Grpc,
    metadata::MetadataKey,
    transport::{Channel, Endpoint},
};

use super::Executable;
use crate::{codec::DynamicProstCodec, descriptor_set::DescriptorSet, util::new_tokio_rt};

/// Print the version of the application.
#[derive(FromArgs, Clone, Debug)]
#[argh(subcommand, name = "client")]
pub struct ClientCommand {
    /// the target server address, it should contain the scheme, e.g. `http://` and `unix://`
    #[argh(option, short = 's')]
    server: String,

    /// the path to the grpc proto descriptor set file. could be generated by `protoc` or `compile` command of this tool.
    #[argh(option, short = 'D')]
    descriptor_set: PathBuf,

    /// disable package emission, which means the package name will not be used in the request.
    #[argh(switch)]
    disable_package_emission: bool,

    /// the gRPC method to call, e.g. `helloworld.Greeter.SayHello`
    #[argh(positional)]
    method: String,

    /// the request data in JSON format. Leave it empty to use the default value.
    #[argh(option, short = 'd')]
    data: Option<String>,

    /// the request header in format of `key=value`. This option can be used multiple times.
    #[argh(option, short = 'h')]
    header: Vec<String>,
}

impl Executable for ClientCommand {
    fn run(&self) -> anyhow::Result<()> {
        let ds = DescriptorSet::from_file(&self.descriptor_set)?;
        let pool = ds.pool();

        let (service_name, method_name) = self.method.rsplit_once(".").ok_or_else(|| {
            anyhow::anyhow!(
                "Invalid method format. It should look like `helloworld.Greeter.SayHello`"
            )
        })?;

        let service = pool
            .get_service_by_name(service_name)
            .ok_or_else(|| anyhow::anyhow!("Service not found: {service_name}"))?;

        let method = service
            .methods()
            .find(|x| x.name() == method_name)
            .ok_or_else(|| anyhow::anyhow!("Method not found: {method_name}"))?;

        let headers = self
            .header
            .iter()
            .map(|x| {
                let (key, value) = x.split_once('=').unwrap_or((x.as_str(), ""));
                (key.to_string(), value.to_string())
            })
            .collect::<Vec<_>>();

        let req_type = method.input();
        let resp_type = method.output();

        let req_msg: DynamicMessage = match &self.data {
            Some(data) => {
                let mut req_msg_json_de = serde_json::de::Deserializer::from_str(data);
                let msg = DynamicMessage::deserialize_with_options(
                    req_type.clone(),
                    &mut req_msg_json_de,
                    &DeserializeOptions::new().deny_unknown_fields(true),
                )?;
                req_msg_json_de.end()?;
                msg
            }
            None => DynamicMessage::new(req_type.clone()),
        };

        let resp_msg = {
            let task = async move {
                call_grpc_method(
                    connect_grpc(self.server.clone()).await?,
                    format!(
                        "/{}/{method_name}",
                        if self.disable_package_emission {
                            service.name()
                        } else {
                            service.full_name()
                        }
                    ),
                    headers,
                    req_msg,
                    DynamicProstCodec::new(req_type.clone(), resp_type.clone()),
                )
                .await
            };

            new_tokio_rt().block_on(task)?
        };

        println!("{}", serde_json::to_string(&resp_msg)?);

        Ok(())
    }
}

async fn connect_grpc(server: String) -> anyhow::Result<Grpc<Channel>> {
    let ch = Endpoint::from_shared(server.clone())?.connect().await?;
    let mut client = Grpc::new(ch);

    client.ready().await?;

    Ok(client)
}

async fn call_grpc_method(
    mut client: Grpc<Channel>,
    path: String,
    headers: Vec<(String, String)>,
    msg: DynamicMessage,
    codec: DynamicProstCodec,
) -> anyhow::Result<DynamicMessage> {
    let path = PathAndQuery::from_maybe_shared(path).unwrap();
    let mut req = Request::new(msg);
    for (key, value) in headers {
        // TODO: handle binary metadata
        req.metadata_mut().insert(
            MetadataKey::from_bytes(key.as_bytes()).unwrap(),
            value.parse().unwrap(),
        );
    }

    client.ready().await?;

    // TODO: support streaming
    let resp: Response<DynamicMessage> = dbg!(client.unary(req, path, codec).await)?;

    Ok(resp.into_inner())
}
