use std::{net::IpAddr, path::PathBuf, str::FromStr, sync::Arc};

use argh::FromArgs;
use http::{Uri, uri::PathAndQuery};
use hyper_util::rt::TokioIo;
use prost_reflect::{DeserializeOptions, DynamicMessage};
use tokio::net::TcpStream;
use tokio_rustls::{
    TlsConnector,
    rustls::{
        ClientConfig,
        pki_types::{DnsName, ServerName},
    },
};
use tonic::{
    Request, Response, Streaming,
    client::Grpc,
    metadata::MetadataKey,
    transport::{Channel, Endpoint},
};
use tower::service_fn;

use super::Executable;
use crate::{
    codec::DynamicProstCodec, descriptor_set::DescriptorSet, tls::NullVerifier, util::new_tokio_rt,
};

/// Print the version of the application.
#[derive(FromArgs, Clone, Debug)]
#[argh(subcommand, name = "client")]
pub struct ClientCommand {
    /// the target server address, it should contain the scheme, e.g. `http://` and `unix://`
    #[argh(option, short = 's')]
    server: String,

    // /// skip the TLS verification. This option is useful when you are using a self-signed certificate.
    // #[argh(switch)]
    // skip_tls_verify: bool,
    /// the path to the grpc proto descriptor set file. could be generated by `protoc` or `compile` command of this tool.
    #[argh(option, short = 'D')]
    descriptor_set: PathBuf,

    /// disable package emission, which means the package name will not be used in the request.
    #[argh(switch)]
    disable_package_emission: bool,

    /// the gRPC method to call, e.g. `helloworld.Greeter.SayHello`
    #[argh(positional)]
    method: String,

    /// the request data in JSON format. Leave it empty to use the default value.
    #[argh(option, short = 'd')]
    data: Option<String>,

    /// the request header in format of `key=value`. This option can be used multiple times.
    #[argh(option, short = 'h')]
    header: Vec<String>,
}

impl Executable for ClientCommand {
    fn run(&self) -> anyhow::Result<()> {
        let ds = DescriptorSet::from_file(&self.descriptor_set)?;
        let pool = ds.pool();

        let (service_name, method_name) = self.method.rsplit_once(".").ok_or_else(|| {
            anyhow::anyhow!(
                "Invalid method format. It should look like `helloworld.Greeter.SayHello`"
            )
        })?;

        let service = pool
            .get_service_by_name(service_name)
            .ok_or_else(|| anyhow::anyhow!("Service not found: {service_name}"))?;

        let method = service
            .methods()
            .find(|x| x.name() == method_name)
            .ok_or_else(|| anyhow::anyhow!("Method not found: {method_name}"))?;

        let headers = self
            .header
            .iter()
            .map(|x| {
                let (key, value) = x.split_once('=').unwrap_or((x.as_str(), ""));
                (key.to_string(), value.to_string())
            })
            .collect::<Vec<_>>();

        let req_type = method.input();
        let resp_type = method.output();

        let req_msg: DynamicMessage = match &self.data {
            Some(data) => {
                let mut req_msg_json_de = serde_json::de::Deserializer::from_str(data);
                let msg = DynamicMessage::deserialize_with_options(
                    req_type.clone(),
                    &mut req_msg_json_de,
                    &DeserializeOptions::new().deny_unknown_fields(true),
                )?;
                req_msg_json_de.end()?;
                msg
            }
            None => DynamicMessage::new(req_type.clone()),
        };

        let rt = new_tokio_rt();
        let client = rt.block_on(connect_grpc(self.server.clone()))?;
        let path = format!(
            "/{}/{method_name}",
            if self.disable_package_emission {
                service.name()
            } else {
                service.full_name()
            }
        );
        let codec = DynamicProstCodec::new(req_type.clone(), resp_type.clone());

        if method.is_server_streaming() {
            let task = async move {
                let mut stream =
                    call_grpc_server_streaming_method(client, path, headers, req_msg, codec)
                        .await?;

                while let Some(msg) = stream.message().await? {
                    println!("{}", serde_json::to_string(&msg)?);
                }

                Ok::<_, anyhow::Error>(())
            };

            rt.block_on(task)?;
        } else {
            let resp_msg = rt.block_on(call_grpc_method(client, path, headers, req_msg, codec))?;

            println!("{}", serde_json::to_string(&resp_msg)?);
        }

        Ok(())
    }
}

async fn connect_grpc(server: String) -> anyhow::Result<Grpc<Channel>> {
    let ch = if server.starts_with("https://") || server.starts_with("grpcs://") {
        let http_uri = server
            .replacen("https://", "http://", 1)
            .replacen("grpcs://", "grpc://", 1);
        let svc = service_fn(move |u: Uri| async move {
            let host = u.host().expect("host should be present").to_string();
            let port = u.port_u16().unwrap_or(443);

            let conn = TcpStream::connect((host.as_str(), port)).await?;

            let cfg = {
                let mut c = ClientConfig::builder()
                    .dangerous()
                    .with_custom_certificate_verifier(Arc::new(NullVerifier))
                    .with_no_client_auth();
                c.alpn_protocols = vec![b"h2".to_vec()];
                c
            };

            let domain = match IpAddr::from_str(host.trim_matches(['[', ']'])) {
                Ok(ip) => ServerName::IpAddress(ip.into()),
                Err(_) => ServerName::DnsName(
                    DnsName::try_from_str(&host)
                        .expect("invalid domain")
                        .to_owned(),
                ),
            };

            TlsConnector::from(Arc::new(cfg))
                .connect(domain, conn)
                .await
                .map(TokioIo::new)
                .map_err(|e| anyhow::anyhow!("TLS connection failed: {}", e))
        });
        Endpoint::from_shared(http_uri)?
            .connect_with_connector(svc)
            .await?
    } else {
        Endpoint::from_shared(server.clone())?.connect().await?
    };
    let mut client = Grpc::new(ch);

    client.ready().await?;

    Ok(client)
}

async fn call_grpc_method(
    mut client: Grpc<Channel>,
    path: String,
    headers: Vec<(String, String)>,
    msg: DynamicMessage,
    codec: DynamicProstCodec,
) -> anyhow::Result<DynamicMessage> {
    let path = PathAndQuery::from_maybe_shared(path).unwrap();
    let mut req = Request::new(msg);
    for (key, value) in headers {
        // TODO: handle binary metadata
        req.metadata_mut().insert(
            MetadataKey::from_bytes(key.as_bytes()).unwrap(),
            value.parse().unwrap(),
        );
    }

    client.ready().await?;

    // TODO: support streaming
    let resp: Response<DynamicMessage> = client.unary(req, path, codec).await?;

    Ok(resp.into_inner())
}

async fn call_grpc_server_streaming_method(
    mut client: Grpc<Channel>,
    path: String,
    headers: Vec<(String, String)>,
    msg: DynamicMessage,
    codec: DynamicProstCodec,
) -> anyhow::Result<Streaming<DynamicMessage>> {
    let path = PathAndQuery::from_maybe_shared(path).unwrap();
    let mut req = Request::new(msg);
    for (key, value) in headers {
        // TODO: handle binary metadata
        req.metadata_mut().insert(
            MetadataKey::from_bytes(key.as_bytes()).unwrap(),
            value.parse().unwrap(),
        );
    }

    client.ready().await?;

    // TODO: support streaming
    let resp: Response<Streaming<DynamicMessage>> =
        client.server_streaming(req, path, codec).await?;

    Ok(resp.into_inner())
}
