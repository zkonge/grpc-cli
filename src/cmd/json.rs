use std::{
    io::{Read, Write},
    path::PathBuf,
};

use argh::FromArgs;
use base64::{Engine, prelude::BASE64_STANDARD};
use prost::Message;
use prost_reflect::DynamicMessage;

use super::Executable;
use crate::descriptor_set::DescriptorSet;

/// Print the version of the application.
#[derive(FromArgs, Clone, Debug)]
#[argh(subcommand, name = "json")]
pub struct JsonCommand {
    /// the path to the grpc proto descriptor set file. could be generated by `protoc` or `compile` command of this tool.
    #[argh(option, short = 'D')]
    descriptor_set: PathBuf,

    /// protobuf message type name, e.g. `helloworld.Greeter.SayHelloRequest`.
    #[argh(positional)]
    message: String,

    /// reverse the conversion. input is JSON, output is protobuf.
    #[argh(switch, short = 'j')]
    json_to_protobuf: bool,

    /// encode the output to base64. this option is only valid when `json_to_protobuf` is set.
    #[argh(switch, short = 'b')]
    base64: bool,

    /// the path to the output file. leave empty means write to stdout.
    #[argh(option, short = 'o')]
    output: Option<PathBuf>,

    /// the path to the input file. leave empty means read from stdin.
    #[argh(option, short = 'i')]
    input: Option<PathBuf>,
}

impl Executable for JsonCommand {
    fn run(&self) -> anyhow::Result<()> {
        let ds = DescriptorSet::from_file(&self.descriptor_set)?;
        let pool = ds.pool();

        let msg_type = pool
            .get_message_by_name(&self.message)
            .ok_or_else(|| anyhow::anyhow!("Message not found: {}", self.message))?;

        let input = if let Some(input) = &self.input {
            std::fs::read(input)?
        } else {
            let mut buf = Vec::new();
            std::io::stdin().read_to_end(&mut buf)?;
            buf
        };

        let data = if self.json_to_protobuf {
            let mut json_de = serde_json::de::Deserializer::from_slice(&input);
            let msg = DynamicMessage::deserialize(msg_type, &mut json_de)?;
            json_de.end()?;
            let bin_message = msg.encode_to_vec();

            if self.base64 {
                BASE64_STANDARD.encode(bin_message).into_bytes()
            } else {
                bin_message
            }
        } else {
            let msg = DynamicMessage::decode(msg_type, input.as_slice())?;
            serde_json::to_vec(&msg)?
        };

        if let Some(output) = &self.output {
            std::fs::write(output, data)?;
        } else {
            std::io::stdout().write_all(&data)?;
        }

        Ok(())
    }
}
